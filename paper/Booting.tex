\section{Booting}

Whenever a computer starts up, there is a fixed set of instructions that
have to be performed to initialize the system correctly. This routine is
called a system startup. In IBM-PC compatible systems, the system startup
is done by the Basic Input Output System (BIOS). The BIOS is firmware
that is stored on the motherboard and is executed automatically. On newer systems there is
more powerful but also more complex firmware available, namely the UEFI BIOS. We
will cover the differences between the two later but they both handle the
system initialisation. One of the firmware's main tasks is doing the Power-On
Self-Test (POST) which checks the presence and the
integrity of hardware components such as the processor, RAM, keyboard,
GPU as well as storage devices. If system critical components such as 
RAM or the processor are not present, the PC speaker will let of a beep
and turn off. After a successfull POST, the BIOS will gather some details
about the hardware and write some basic
information of the hardware into the Bios Data Area (BDA). Because the BIOS
prepares the machine for an operating system (OS) it presents the hardware
details in a format that can be read by the OS.
The BDA is a
data structure that is located in memory at location 0x400-0x4FF and
can be read as soon as the operating system has been loaded. Slightly newer BIOSes also
write to the Extended BDA where more modern hardware information can be
found. Afterwards, the BIOS configures hardware such as the system clock
to keep in sync with time and sets up interrupt handlers (more about
interrupts in chapter XXXXXXXX). Finally, the BIOS will search all the
attached storage devices for a bootloader sector. The search order can be
set in the BIOS's settings. Identifying a bootloader sector of a storage device is
done by comparing the 511. and 512. byte of the first sector of the storage medium
with the values 0x55 and 0xAA respectively. These values were initially
arbitrarily chosen by the original equipment manufacterers as the 
identifying number for bootsectors. When the BIOS finds a valid
bootloader sector, it will load the entire sector into RAM at the fixed
location 0x7C00. Yet again, this value was chosen randomly by the OEM's
back in the 1970s but to this day IBM-PC compatible systems will load
the bootsector into that location. After a successfull load, the BIOS
will transfer control to the bootloader by telling the CPU to fetch
instructions from location 0x7C00.


\subsection{Bootloader}

The bootloader has 2 important tasks. The first one is gathering more
information about the RAM of the system. It will determine wether there is
enough RAM to load the OS and if this is true it will load the OS. Loading
the OS means that it will access the storage device and read a number of
sectors into memory using a BIOS interrupt. The number of sectors depends on
the size of the OS on the storage device. A BIOS interrupt can be thought of
as a function provided by the BIOS that the bootloader can call. There are
multiple interrupts but only one of them can be used to read sectors into
RAM. It is interrupt number 0x13 in hex or decimal 19 and it is invoked with parameters that will load $x$ many sector on $y$ many platters into RAM
address determined by a parameter. After a successful load the bootloader
hands over the execution to the operating system, specifically the \textit{kernel}. \footnote{Booting in Operating system in: Javapoint, \today \\ https://www.javatpoint.com/booting-in-operating-system}

\subsection{Kernel}

The kernel is the most important part of the OS. It controls hardware and it
manages all \textit{system resources}. System resources are both digital or physical
components of a computer that are shared between multiple users and all their
running programs. Examples of such system resources are:
\begin{itemize}
\item Processes; programs are started by other programs and users but they are maaged by the kernel.
	CPU time; There might be a hundred processes running but there aren't a hundred processors available. The kernel will offer every process a \textit{time slice}during which a process will be running on the CPU (core).
\item Memory; We don't want a process to interfere with other processes' memory. It is a Kernels job to manage memory to avoid inter process interference. Memory that is managed by a kernel is called \textit{Virtual Memory} (VM).
\item Internet access; Taking care of internet packets is also one of the kernels jobs.
\item Direct hardware access; Direct hardware access is done by the kernel through device drivers. A program may ask the kernel for disk access and the kernel will either grant or refuse it. If the kernel grants access it will tell the driver to perform the hardware specific operation requested by the program
\end{itemize}
There are many more, some of which will be explained later in this booklet.
But one can clearly see that a kernel must take care of a lot of stuff. It
is because of that reason that the kernel is the most important part of an
operating system; as it ensures everything is working (more or less)
correctly. It is important to point out that the kernel on its own is useless
without other components of an operating system because there aren't any
system resources to manage if no one is requesting any.
The other components of an
operating system are programs that create an environment that provide an user
experience. Such programs are responsible for things such as graphical user
interfaces (GUIs) or text user interfaces (TUIs) and a \textit{shell}. A shell is a
program that reads text-only commands and performs the requested commands. It
is called \textit{shell} because it is the outer layer of an operating system. Users
interact with said outer layer and there are many different implementations
of shells. Summarized, an operating system is made out of a kernel and many programs working on top of the kernel that provide an user experience. \footnote{Bellevue Linux Users Group: Kernel Definition, \today \\ http://www.linfo.org/kernel.html}


hard disk and a
file. The Kernel will ensure that the hard disk can be read from and written
to by programs just like it will also manage the reading and writing of a
file. There are hundreds of different hard disk drives and they all work a
bit differently. If every program had its own 

\subsection{UEFI}
