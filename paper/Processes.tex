\section{Processes}

A process is defined as an instance of a computer program that is currently being executed.
The operating system is ultimately in control of all the processes and 
Processes can be further categorized into what is called a \textit{process life cycle}. The process life cycle is
a categorization of the different states a process or program can be in. A process life cycle can vary
from one operating system to another and the names are also not standardized. The aforementioned 
categorisation consists of 5 different stages:

\begin{itemize}
\item Start: \\
The original state in which a process is first initiated in.
\item Ready: \\
A ready process in in wait for the processor to allocate them via the operating system. Processes will
likely enter this state after the Start state. The other likely reason why a process enters this stage
is because the OS scheduler(part of the operating system that manages CPU allocation to processes) will
interrupt the process to assign the CPU to another process.
\item Running:
In this state the process has been assigned the CPU by the OS scheduler and executes its instructions.
\item Waiting: \\
This is the stage in which the process is waiting for a resource such as waiting for a file to become available
or waiting for user input.
<item Exit/Terminate: \\

This is the last state a process enters when it has finished with its execution. The process is then removed
from main memory. \footnote{Processes, from: Medium, \today   \\ https://medium.com/@imdadahad/a-quick-introduction-to-processes-in-computer-science-271f01c780da}

\end{itemize}

\subsection{Threads}

Threads are the most basic unit of CPU utilisation, meaning that this is the smallest amount that the workload of a 
process can be split. Threads consist of a stack, a set of registers and a program counter. Usually a process
is tied to strictly one thread meaning that the CPU does not split the workload over multiple threads. However in
modern programming often multiple threads are used by one process to perform different tasks independently at the
same time. This is very useful in modern programming because this means that a task in a process will not block 
other task. For example a program like word can check for user input with one thread, load images on a second thread,
check for grammar errors on a third thread and make backups on a fourth thread. Each thread has its own set of registers
and a stack but all threads share the same files, code and data. Modern CPUs have multiple cores meaning that they have
multiple processing units this allows multiple threads to do parallel processing because each thread is strictly
related to one processing unit. This type of programming that uses threads to complete mutliple tasks
in parallel is reffered to as multi-threading and this benefits four main categories:


\begin{itemize}
\item Sclalability: \\

Multi-threading allows programmers to utilize multiple CPU cores for a single process as opposed to single
thread processes which can only utilize a single CPU core.

\item Responsiveness: \\

When threads are still occupied with tasks in the process multi-threading allows for another thread
to still check for input and thus allowes rapid responce from the user.

\item Economy: \\

Multi-threading is much faster than single thread processes. Managing and creating threads allows for
faster completion of tasks.

\item Resource sharing: \\

Threads share their recources amongst each other allowing for tasks to be completed in parallel in a
single adress space. \footnote{Threads, from: Uic \today \\ https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4\_Threads.html }

\end{itemize}

\subsection{Program}

A program is a file containing a set of instructions. These instructions can be written in many different 
programming languages such as: Python, C or C++. These are considered high lever programming languages as 
they have strong abstraction from the inner machinations of a computer. The CPU however cammpt read these 
instructions yet they first need to be translated into something that the computer can use. This is done 
via a compiler. The compiler translates when this program is loaded into memory it becomes a process and can 
be seperated into four parts:

\begin{itemize}
\item The Stack: \\

The stack contains primarly local variables but also data such as function parameters and function return adresses. The data on the stack is often just used temporarily.
\item The Heap: \\

The heap contains memory that is dynamically allocated during the run time of the process.
\item The Data: \\

The data is the section containing the static and global variables.
\item The Text: \\

The text segment contains CPU instructions for the process, this is represented by the value of the program counter it also contains the contents of the processor's registers.

\end{itemize}

Further iformation on these four sections can be found within the memory chapter. \footnote{Processes, from: Tutorialspoint, \today \\ \url{https://www.tutorialspoint.com/operating_system/os_processes.htm} }


\subsection{Daemons and Init}

Daemons are computer programs that run in the background of an operating system. Regular users (i.e. users without \textit{Administrator rights} a.k.a \textit{root privileges} on unix-derivatives)
do not have direct access to daemon processes and have no control over them. The implementation for daemons will differ from
operating system platforms. For Microsoft Windows NT systems, the programs that serve the same functions as 
daemons are called \textit{Windows services}. In most cases they do not interact with user input and are started 
during the boot directly by the kernel. Since Windows 2000, the services can be manually started and stopped via the control panel\footnote{Services, from: Microsoft, \today \\ \url{https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc783643(v=ws.10)?redirectedfrom=MSDN}}.
In Unix-like systems, daemon processes usually end with the letter "d" for example the crond daemon is 
a job scheduler for background processes. In Unix systems there is also a special daemon from which all
other daemons spawn the init daemon. The init daemon is the first process to be started at system boot 
and then places the sytem in single user mode or spawns a shell to read the system's startup files. \footnote{Verma: Unix, (2006) P. 84 \\ \url{https://books.google.ch/books?id=JhS-TkW0tOYC&pg=PA84&redir_esc=y#v=onepage&q&f=false}}



\subsection{Executables}

Executables are files containing instructions and data for computers. When these files are \textit{run}, they
become procesess. Running a executable means that the contents of the file are loaded into memory. Executables
are associated with a format that describes how exactly the contents must be loaded. The loading itself
is done by the \textit{program loader}. It is a crucial component in operating systems. The program loader
maps the individual sections, primarily \texttt{.text} and \texttt{.data}, of an executable into memory according to the layout and position
specified in the executable. 

\subsubsection{Binary executables}



\subsubsection{Scripts}

There is also a different type of executables, namely *scripts*. Scripts are written in a human readable
scripting language. They rely on software to interprete the instructions at run time in contrast of
hardware (such as the CPU). The interpreting software is a program that contains instructions for
the CPU. Windows uses the \textbf{.bat} or \textbf{.cmd} extension for scripts written for the interpreter \texttt{cmd.exe} and for
the newer PowerShell scripts with extension \textbf{.ps1} it will use the interpreter called \texttt{powershell.exe}.


\subsubsection{Executables on unix-like systems}

Unix-like operating systems differ greatly from Windows NT ones. They rarely rely on extensions to
identify executables but rather *file signatures*. Binary executables unix systems with the exception of MacOS
contain the \texttt{\textbackslash x7fELF} file signature and are in the ELF-format. A special type of file signature can be found on
scripts. Even though they are made of plain ASCII characters, the author of the file creates the
signature by him or herself. In scripts for Unix-like operating systems, the format is as follows: \\
\texttt{\#!/path/to/the/script/interpreter -parameters\textbackslash n} followed by instructions in the scripting language that can
be interpreted by the interpreter specified in the path. The \textit{shebang} (\textbf{\#!}) is the script signature
and tells the kernel that the program is not in a binary format such as Mach-O (MacOS Darwin) or ELF (Linux et al.),
the unix-like counterparts to Windows \textbf{.exe} (PE). When the executable is invoked,
the kernel will first invoke the interpreter, which is a binary executable and pass the name of the script
to the interpreter.







%stuff:
%[^proc1]: https://medium.com/@imdadahad/a-quick-introduction-to-processes-in-computer-science-271f01c780da
%[^proc2]: https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html 
%[^proc3]: https://www.tutorialspoint.com/operating_system/os_processes.htm
%[^proc4]: https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc783643(v=ws.10)?redirectedfrom=MSDN
%[^proc5]: https://books.google.ch/books?id=JhS-TkW0tOYC&pg=PA84&redir_esc=y#v=onepage&q&f=false












